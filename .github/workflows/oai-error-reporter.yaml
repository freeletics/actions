name: OAI Error Reporter

on:
  workflow_call:
    inputs:
      job_name:
        description: 'The name of the job to inspect for failures.'
        required: true
        type: string
      model:
        description: 'The AI model to use for analysis.'
        required: true
        type: string
      endpoint:
        description: 'The API endpoint for OpenWebUI.'
        required: true
        type: string
      issue_label:
        description: 'Labels to add to the created GitHub issue.'
        required: false
        default: 'ci-failure'
        type: string
    secrets:
      OPENWEBUI_API_KEY:
        description: 'The API key for OpenWebUI.'
        required: true

permissions:
  issues: write
  actions: read
  contents: read

jobs:
  report_errors:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Fetch Failed Steps
      - name: Fetch Failed Steps
        id: fetch_failures
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const jobName = '${{ inputs.job_name }}';
            const runId = context.runId;
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId,
            });

            const targetJob = jobs.jobs.find(job => job.name === jobName);

            if (!targetJob) {
              throw new Error(`Job "${jobName}" not found.`);
            }

            const failedSteps = targetJob.steps.filter(step => step.conclusion === 'failure');

            if (failedSteps.length === 0) {
              core.info(`No failed steps found in job "${jobName}".`);
              return { failures: '' };
            }

            let summary = '';
            failedSteps.forEach(step => {
              summary += `- **${step.name}**: ${step.conclusion}\n`;
            });

            core.setOutput('failures', summary);

      # Step 2: Send Errors to OpenWebUI and Get Analysis
      - name: Send Errors to OpenWebUI and Get Analysis
        id: bot_response
        if: steps.fetch_failures.outputs.failures != ''
        run: |
          echo "Sending errors to OpenWebUI..."

          # Ensure jq is installed
          if ! command -v jq &> /dev/null
          then
              echo "jq could not be found. Installing..."
              sudo apt-get update && sudo apt-get install -y jq
          fi

          # Prepare the JSON payload using inputs
          PAYLOAD=$(jq -n \
            --arg model "${{ inputs.model }}" \
            --arg content "The following steps have failed in the job \"${{ inputs.job_name }}\":\n${{ steps.fetch_failures.outputs.failures }}\n\nPlease analyze these errors and provide recommendations." \
            '{
              model: $model,
              messages: [
                {
                  role: "user",
                  content: $content
                }
              ]
            }')

          # Send the POST request and capture the response
          RESPONSE=$(curl -s -X POST "${{ inputs.endpoint }}" \
            -H "Authorization: Bearer ${{ secrets.OPENWEBUI_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")

          echo "Response from OpenWebUI: $RESPONSE"

          # Extract the bot's message using jq
          BOT_MESSAGE=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')

          echo "Bot's analysis: $BOT_MESSAGE"

          # Set the bot's message as an output
          echo "analysis=$BOT_MESSAGE" >> $GITHUB_OUTPUT

      # Step 3: Create GitHub Issue with Bot's Analysis
      - name: Create GitHub Issue with Analysis
        if: steps.bot_response.outputs.analysis != ''
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const analysis = `\`\`\`
            ${{ steps.bot_response.outputs.analysis }}
            \`\`\``;
            const failures = `\`\`\`
            ${{ steps.fetch_failures.outputs.failures }}
            \`\`\``;
            const issueTitle = "⚠️ CI Pipeline Failures Detected";
            const issueBody = `
            **CI Pipeline Failures Summary:**
            ${failures}

            **Bot Analysis and Recommendations:**
            ${analysis}

            **Workflow Run Details:**
            - Repository: \`${context.repo.owner}/${context.repo.repo}\`
            - Workflow: \`${context.workflow}\`
            - Run ID: \`${context.runId}\`
            - Run URL: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}

            Please review the failures and follow the bot's recommendations to resolve the issues.
            `;

            // Define owner and repo from context
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Check if an issue with the same title already exists
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: owner,
              repo: repo,
              state: 'open',
              labels: ['${{ inputs.issue_label }}'],
            });

            const issueExists = existingIssues.some(issue => issue.title === issueTitle);

            if (!issueExists) {
              await github.rest.issues.create({
                owner: owner,
                repo: repo,
                title: issueTitle,
                body: issueBody,
                labels: ['${{ inputs.issue_label }}']
              });
              console.log("GitHub issue with bot analysis created successfully.");
            } else {
              console.log("An issue for CI failures already exists.");
            }

name: OAI Error Reporter

on:
  workflow_call:
    inputs:
      job_name:
        description: 'The name of the job to inspect for failures.'
        required: true
        type: string
      model:
        description: 'The AI model to use for analysis.'
        required: true
        type: string
      endpoint:
        description: 'The API endpoint for OpenWebUI.'
        required: true
        type: string
      issue_label:
        description: 'Labels to add to the created GitHub issue.'
        required: false
        default: 'ci-failure'
        type: string
    secrets:
      OPENWEBUI_API_KEY:
        description: 'The API key for OpenWebUI.'
        required: true

permissions:
  issues: write
  actions: read
  contents: read

jobs:
  report_errors:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Fetch Failed Steps and Their Logs
      - name: Fetch Failed Steps and Logs
        id: fetch_failures
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const jobName = '${{ inputs.job_name }}';
            const runId = context.runId;
            
            // Get all jobs from the workflow run
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId,
            });

            const targetJob = jobs.jobs.find(job => job.name === jobName);
            if (!targetJob) {
              throw new Error(`Job "${jobName}" not found.`);
            }

            // Get the logs for the job
            const logs = await github.rest.actions.downloadJobLogsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              job_id: targetJob.id,
              accept: 'application/vnd.github.v3+json',
            });

            const failedSteps = targetJob.steps.filter(step => step.conclusion === 'failure');
            if (failedSteps.length === 0) {
              core.info(`No failed steps found in job "${jobName}".`);
              return { failures: '', logs: '' };
            }

            let summary = '';
            failedSteps.forEach(step => {
              summary += `- **${step.name}**: ${step.conclusion}\n`;
            });

            // Set both the summary and full logs as outputs
            core.setOutput('failures', summary);
            core.setOutput('logs', Buffer.from(logs.data).toString('base64'));

      - name: Send Errors to OpenWebUI and Get Analysis
        id: bot_response
        if: steps.fetch_failures.outputs.failures != ''
        run: |
          echo "Sending errors to OpenWebUI..."

          # Ensure jq is installed
          if ! command -v jq &> /dev/null
          then
              echo "jq could not be found. Installing..."
              sudo apt-get update && sudo apt-get install -y jq
          fi

          # Decode the base64 logs and ensure it's properly formatted
          FULL_LOGS=$(echo "${{ steps.fetch_failures.outputs.logs }}" | base64 -d | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
          
          # Create a temporary file for the content
          CONTENT_FILE=$(mktemp)
          echo "The following steps have failed in the job \"${{ inputs.job_name }}\":" > "$CONTENT_FILE"
          echo "${{ steps.fetch_failures.outputs.failures }}" >> "$CONTENT_FILE"
          echo -e "\nFull job logs:" >> "$CONTENT_FILE"
          echo "$FULL_LOGS" >> "$CONTENT_FILE"
          echo -e "\nPlease analyze these errors, identify the root cause, and provide specific recommendations for fixing the issues." >> "$CONTENT_FILE"

          # Debug: Print the content file
          echo "Debug - Content of CONTENT_FILE:"
          cat "$CONTENT_FILE"

          # Create the JSON payload and save to a file for inspection
          PAYLOAD_FILE=$(mktemp)
          jq -n \
            --arg model "${{ inputs.model }}" \
            --arg content "$(cat "$CONTENT_FILE")" \
            '{
              model: $model,
              messages: [
                {
                  role: "user",
                  content: $content
                }
              ]
            }' > "$PAYLOAD_FILE"

          # Debug: Print the payload
          echo "Debug - Content of PAYLOAD_FILE:"
          cat "$PAYLOAD_FILE"

          # Send the POST request and capture the response
          echo "Debug - Sending request to: ${{ inputs.endpoint }}"
          RESPONSE=$(curl -v -X POST "${{ inputs.endpoint }}" \
            -H "Authorization: Bearer ${{ secrets.OPENWEBUI_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "@$PAYLOAD_FILE" 2>&1)

          # Debug: Print the response (excluding sensitive data)
          echo "Debug - API Response:"
          echo "$RESPONSE" | grep -v "Authorization:"

          # Check if the response is valid JSON
          if echo "$RESPONSE" | jq empty > /dev/null 2>&1; then
            echo "Valid JSON response received"
            # Extract the bot's message and store it as a base64-encoded string
            BOT_MESSAGE=$(echo "$RESPONSE" | jq -r '.choices[0].message.content' | base64 -w 0)
            echo "analysis=$BOT_MESSAGE" >> $GITHUB_OUTPUT
          else
            echo "Error: Invalid JSON response received"
            echo "Raw response:"
            echo "$RESPONSE"
            exit 1
          fi

          # Clean up temporary files
          rm "$CONTENT_FILE" "$PAYLOAD_FILE"

      # Step 3: Create GitHub Issue with Analysis
      - name: Create GitHub Issue with Analysis
        if: steps.bot_response.outputs.analysis != ''
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Decode the base64-encoded analysis
            const analysis = Buffer.from('${{ steps.bot_response.outputs.analysis }}', 'base64').toString();
            const failures = `${{ steps.fetch_failures.outputs.failures }}`;

            const issueTitle = "⚠️ CI Pipeline Failures Detected";
            const issueBody = `
            **CI Pipeline Failures Summary:**
            \`\`\`
            ${failures}
            \`\`\`

            **Bot Analysis and Recommendations:**
            \`\`\`
            ${analysis}
            \`\`\`

            **Workflow Run Details:**
            - Repository: \`${context.repo.owner}/${context.repo.repo}\`
            - Workflow: \`${context.workflow}\`
            - Run ID: \`${context.runId}\`
            - Run URL: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}

            Please review the failures and follow the bot's recommendations to resolve the issues.
            `;

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Check if an issue with the same title already exists
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: owner,
              repo: repo,
              state: 'open',
              labels: ['${{ inputs.issue_label }}'],
            });

            const issueExists = existingIssues.some(issue => issue.title === issueTitle);

            if (!issueExists) {
              await github.rest.issues.create({
                owner: owner,
                repo: repo,
                title: issueTitle,
                body: issueBody,
                labels: ['${{ inputs.issue_label }}']
              });
              console.log("GitHub issue with bot analysis created successfully.");
            } else {
              console.log("An issue for CI failures already exists.");
            }
